{
  "code": 200,
  "message": "success",
  "traceId": "63891db8-a1c5-4331-920b-9b4c5be6755f",
  "data": {
    "list": [
      {
        "articleId": 149066473,
        "title": "Android上使用无障碍服务(AccessibilityService)完成一键拨打微信视频电话",
        "description": "摘要：本文介绍了如何利用Android的无障碍服务(AccessibilityService)实现智能辅助功能，如简化视频通话操作。通过继承AccessibilityService并配置相应参数（如监听窗口变化、设置反馈类型等），开发者可以获取页面控件信息并模拟点击操作。文章详细讲解了服务注册、配置文件属性（包括事件类型、包名过滤、手势操作等）及代码实现要点，强调应合法使用该技术为视障用户等特殊群体开发便捷工具，而非用于违法用途。核心是通过系统回调获取界面节点，实现自动化交互功能。",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/149066473",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 778,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=149066473",
        "postTime": "2025-07-02 12:06:58",
        "diggCount": 28,
        "formatTime": "昨天 12:06",
        "picList": [],
        "collectCount": 22,
        "tags": [
          "android",
          "无障碍服务",
          "一键拨打微信视频"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 149066405,
        "title": "kotlin中的内联函数:inline,noinline,crossinline,参数内联,非局部返回",
        "description": "Kotlin中的inline、noinline和crossinline关键字详解： inline关键字用于函数内联，将函数体直接复制到调用处，减少函数调用开销，允许lambda参数非局部返回。适用于高阶函数以减少对象创建，但会增加代码体积。 noinline关键字标记不被内联的lambda参数，用于需要保留函数对象的情况（如作为返回值或传递给非inline函数）。当inline函数的参数需要作为对象使用时必须添加。 crossinline关键字确保lambda参数不会非局部返回，防止lambda中的retu",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/149066405",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 508,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=149066405",
        "postTime": "2025-07-02 11:45:30",
        "diggCount": 16,
        "formatTime": "昨天 11:45",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kotlin",
          "内联函数",
          "inline",
          "noinline",
          "crossinline",
          "参数内联",
          "非局部返回"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 149043732,
        "title": "kotlin中的Unit和Nothing 关键字",
        "description": "Kotlin的类型系统以Any为根类型，所有非空类型都是Any的子类。可空类型(如String?)通过\"?\"表示，在类型层次上可视为非空类型的父类。Unit是类似Java void的返回类型，但作为真实存在的单例对象，实现了类型一致性。Nothing表示永不返回的类型，用于异常函数和泛型空白填充。类型继承关系支持多继承，并通过子类型/父类型检查确保类型安全。这些特性共同构成了Kotlin强大的类型系统，既保持了严谨性又提供了灵活性。",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/149043732",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 945,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=149043732",
        "postTime": "2025-07-01 12:03:09",
        "diggCount": 25,
        "formatTime": "前天 12:03",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kotlin"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 149043712,
        "title": "kotlin中的 object 关键字:kotlin单例,kotlin静态方法,kotlin伴生对象,伴生对象,companion",
        "description": "Kotlin中的object关键字有两种主要用法：对象表达式和对象声明。对象表达式用于创建匿名类（一次性使用），支持继承类和实现接口，常用于局部作用域；对象声明则用于实现单例模式（全局唯一实例），可以嵌套在其他类或对象中。此外，data object简化了单例对象的打印和比较，而companion object（伴生对象）替代了静态成员，可通过@JvmStatic生成真正的静态方法。两者的核心区别在于作用域与生命周期：对象表达式是临时的，对象声明是持久的单例。",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/149043712",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 596,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=149043712",
        "postTime": "2025-07-01 11:55:47",
        "diggCount": 23,
        "formatTime": "前天 11:55",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "kotlin",
          "伴生对象"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 149029089,
        "title": "kotlin委托：,委托属性,属性委托,委托类,Delegation,Delegated properties",
        "description": "Kotlin中的by关键字用于实现委托模式，主要分为两类：类/接口委托和属性委托。类委托通过by将接口实现委托给另一个对象，减少模板代码。属性委托则通过by将属性的读写操作委托给其他对象，支持多种标准委托方式： 属性转发：将属性委托给另一个属性，常用于字段重命名 懒加载：使用lazy实现首次访问时才初始化的特性 可观察属性：通过Delegates.observable监听属性变化 可否决变更：使用Delegates.vetoable拦截并决定是否接受新值 相比Java的手动委托，Kotlin的委托模式更简洁",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/149029089",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 808,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=149029089",
        "postTime": "2025-06-30 18:31:45",
        "diggCount": 14,
        "formatTime": "2025.06.30",
        "picList": [],
        "collectCount": 30,
        "tags": [
          "kotlin",
          "委托"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 149029038,
        "title": "kotlin 泛型,逆变,Covariant,协变,Variance,使用处型变,声明处型变,星投影,Star-Projections",
        "description": "泛型中涉及到的概念也不少,型变(Variance)、逆变(Contravariance)、协变(Covariance)、不变(Invariant).在 kotlin 中还有三个关键字inoutwherereified等,在java中同样也有?extends?super?这些概念是啥意思嘞？引用点概念说明型变(Variance)、协变(Covariance)、逆变(Contravariance)和不变(Invariant)是相关但不同的概念.",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/149029038",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 979,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=149029038",
        "postTime": "2025-06-30 18:30:22",
        "diggCount": 33,
        "formatTime": "2025.06.30",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kotlin",
          "泛型",
          "逆变与协变"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148993659,
        "title": "kotlin作用域函数:run、let、also、apply、with",
        "description": "Kotlin作用域函数指南：let、run、with、apply和also的区别与应用 Kotlin提供了五种作用域函数（let、run、with、apply、also），它们都能在对象上下文中执行代码块，但各有特点： let和also使用it引用对象，let返回lambda结果，also返回对象本身 run和with使用this引用对象，run返回lambda结果，with是非扩展函数 apply使用this引用对象并返回对象本身 适用场景： let：处理非空对象或局部变量引入 apply：对象配置（属性",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148993659",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1055,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148993659",
        "postTime": "2025-06-29 09:55:57",
        "diggCount": 13,
        "formatTime": "2025.06.29",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kotlin",
          "作用域函数"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148993630,
        "title": "Kotlin中的函数类型及Lambda表达式：SAM转换,带接收者的函数类型,匿名函数",
        "description": "Kotlin中的高阶函数与函数类型是函数式编程的重要概念。高阶函数指接受或返回函数的函数，是Kotlin协程和框架的基础。函数类型通过参数和返回值类型描述函数，如(String)->Unit表示接受String返回Unit的函数。带接收者的函数类型（如String.()->Unit）允许直接访问接收者对象的成员，与扩展函数类似但使用场景不同。函数实例化可通过Lambda、匿名函数或函数引用实现。带与不带接收者的函数类型可以互相转换，接收者相当于第一个参数。这些概念包括高阶函数、扩展函数、Lamb",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148993630",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 981,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148993630",
        "postTime": "2025-06-29 09:54:16",
        "diggCount": 17,
        "formatTime": "2025.06.29",
        "picList": [],
        "collectCount": 9,
        "tags": [
          "kotlin",
          "lambda",
          "SAM转换"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148958855,
        "title": "Kotlin中的函数类型及扩展函数介绍：扩展函数,扩展属性,函数接收者,带有接收者的函数类型",
        "description": "本文介绍了Kotlin中的扩展功能，包括扩展函数和扩展属性的使用方法。通过示例代码展示了如何为String类型添加新的方法和属性，并探讨了扩展的作用域限制、Java调用方式以及扩展函数的引用问题。作者通过反编译字节码揭示了Kotlin扩展在Java层面的实现原理（静态方法），并指出扩展不能被继承类覆写的特性。最后总结了扩展的学习要点，并列出了后续待学习的内容清单（Lambda表达式、函数类型、关键字等）。文章以实践为导向，结合代码示例和底层实现分析，帮助读者深入理解Kotlin扩展机制。",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148958855",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1024,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148958855",
        "postTime": "2025-06-27 18:26:23",
        "diggCount": 13,
        "formatTime": "2025.06.27",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "kotlin"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148958761,
        "title": "Retrofit流程分析:Retrofit如何创建对象,Retrofit发送请求流程",
        "description": "本文介绍了在Kotlin协程中使用Retrofit时如何配置自定义CallAdapter处理错误。首先需要搭建开发环境并下载Retrofit 2.11.0源码，重点关注Retrofit.Builder的配置过程，包括设置OkHttpClient、baseUrl、序列化转换器、回调执行器等。文章详细解析了build()方法的实现逻辑，包括默认值设置和工厂类添加顺序。最后通过GitHub API示例展示了如何定义网络请求接口并创建服务实例。这些配置方法为后续实现自定义CallAdapter处理协程异常奠定了基础",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148958761",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 632,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148958761",
        "postTime": "2025-06-27 18:22:46",
        "diggCount": 16,
        "formatTime": "2025.06.27",
        "picList": [],
        "collectCount": 23,
        "tags": [
          "retrofit",
          "java",
          "网络"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148919623,
        "title": "在kotlin协程中使用自定义CallAdapter处理错误",
        "description": "摘要 本文介绍如何在Kotlin项目中使用Retrofit 2.11.0配合协程进行网络请求。主要内容包括： 添加Retrofit和Gson转换器依赖 基础API接口声明和同步调用方式 协程支持改造：使用suspend函数直接返回数据对象 错误处理方案：通过try-catch或runCatching处理异常 针对特殊业务场景的自定义CallAdapter方案 定义NetworkResponse密封类区分成功、网络错误和其他异常状态 文章还讨论了如何处理历史遗留项目中HTTP状态码与业务逻辑混合的特殊情况，并",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148919623",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1255,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148919623",
        "postTime": "2025-06-26 10:20:43",
        "diggCount": 27,
        "formatTime": "2025.06.26",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "kotlin",
          "android",
          "CallAdapter"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148919520,
        "title": "riverpod2中的修饰符及注解：监听、观察、选择、记录、重建",
        "description": "Riverpod状态管理中的ref.read与ref.watch区别：watch用于监听变化并重建Widget，read仅用于读取值；select可监听对象特定属性变化；listen响应变化执行回调；autoDispose修饰符使Provider无监听时自动销毁；keepAlive可实现缓存功能。此外，ProviderObserver可用于全局日志记录。这些功能使Riverpod能灵活应对不同状态管理场景。（149字）",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148919520",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 994,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148919520",
        "postTime": "2025-06-26 10:16:56",
        "diggCount": 30,
        "formatTime": "2025.06.26",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "riverpod",
          "flutter"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148865179,
        "title": "flutter状态管理框架riverpod2.x中的各种Provider简介",
        "description": "Riverpod是Flutter新一代状态管理工具，由Provider重构而来，解决了Provider依赖Widget树的问题。通过全局声明Provider实现编译时安全，无需担心ProviderNotFoundException。安装简单，只需添加flutter_riverpod依赖并在入口包裹ProviderScope。使用方式多样：可继承ConsumerWidget获取WidgetRef读取数据，通过Consumer局部更新UI，或使用ConsumerStatefulWidget替代StatefulW",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148865179",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 931,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148865179",
        "postTime": "2025-06-24 10:01:22",
        "diggCount": 19,
        "formatTime": "2025.06.24",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/806c118bc2f7420c8e110ee8636d797a.png"
        ],
        "collectCount": 22,
        "tags": [
          "flutter",
          "riverpod"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148865100,
        "title": "Android使用Protocol Buffer与服务端交互:编译器和 proto 文件",
        "description": "Protocol Buffer是一种高效的数据交换格式，相比JSON/XML具有体积小、跨平台等优势。本文介绍了其使用流程：1)安装protoc编译器；2)编写.proto文件定义数据结构；3)编译生成目标语言代码；4)项目中引入依赖库进行序列化/反序列化操作。文章还展示了Java实现示例，包括构建消息对象、网络传输，以及使用protostuff库直接处理POJO的方法。这种二进制格式虽然性能优越，但需要事先约定数据结构，且数据不可直接阅读。",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148865100",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 292,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148865100",
        "postTime": "2025-06-24 09:55:32",
        "diggCount": 5,
        "formatTime": "2025.06.24",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "android",
          "ProtocalButter"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148847693,
        "title": "flutter中的那些Key：GlobalKey,LocalKey,UniqueKey,ObjectKey,ValueKey，在 diff 算法中是如何起作用的。",
        "description": "文章摘要： 本文通过Dart代码示例演示了Flutter中Widget状态管理的差异，分析了导致界面未更新的原因。作者展示了三种解决方案：改用StatelessWidget、添加UniqueKey或将状态提升到父Widget。核心问题在于Element树的复用机制 - 当Widget交换时，对应的Element并未交换，而State却被保留。文章还引用了Flutter源码中的updateChildren方法，说明框架如何通过Widget.canUpdate和Key来决定Element的复用策略。该案例清晰地",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148847693",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 591,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148847693",
        "postTime": "2025-06-23 15:25:41",
        "diggCount": 18,
        "formatTime": "2025.06.23",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "flutter"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148847667,
        "title": "flutter中的StatefulWidget 是如何创建又是如何更新的？",
        "description": "本文分析了Flutter中StatefulWidget的生命周期和状态更新机制。关键点包括： createState()在StatefulElement构造函数中被调用，建立State与Element的双向引用； 生命周期方法调用顺序：initState()→didChangeDependencies()→build()，通过_firstBuild()触发； 状态更新机制：setState()内部调用markNeedsBuild()标记脏元素，最终由WidgetsBinding调度重绘； 建议在setSta",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148847667",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 888,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148847667",
        "postTime": "2025-06-23 15:23:39",
        "diggCount": 14,
        "formatTime": "2025.06.23",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "flutter"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148828446,
        "title": "flutter：从runApp到挂载根节点",
        "description": "Flutter应用启动流程分析 入口与初始化：Flutter应用通过runApp()启动，调用WidgetsFlutterBinding.ensureInitialized()初始化绑定系统，该对象混入了7个关键Binding类（如手势、渲染、调度等）。 根Widget挂载： 通过attachRootWidget()将传入的Widget绑定到渲染树 使用RenderObjectToWidgetAdapter作为桥梁连接Widget和RenderObject 在attachToRenderTree()中创建根",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148828446",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 886,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148828446",
        "postTime": "2025-06-22 15:51:47",
        "diggCount": 26,
        "formatTime": "2025.06.22",
        "picList": [],
        "collectCount": 23,
        "tags": [
          "flutter"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148828396,
        "title": "使用OkHttp拦截器进行Android慢网络及页面监控",
        "description": "Android应用监控方案：实现慢网络请求与页面生命周期监控 摘要：本文介绍了Android应用监控的两个核心功能实现方案。对于慢网络请求监控，通过分析OkHttp源码，在OkHttpClient构建时添加EventListener来捕获请求各阶段时间点，超过阈值时实时上报。页面打开关闭行为监控则通过在Application中注册ActivityLifecycleCallbacks实现，利用IdleHandler在UI空闲时进行本地存储。存储方案采用mmap技术实现高效文件写入，失败时降级为传统IO方式。两",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148828396",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1127,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148828396",
        "postTime": "2025-06-22 15:50:26",
        "diggCount": 25,
        "formatTime": "2025.06.22",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "okhttp",
          "android",
          "网络"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148817203,
        "title": "搭建Sentry错误监控及Android接入",
        "description": "私有化部署Sentry日志系统指南 本文介绍了在Ubuntu 18.04系统上私有化部署Sentry日志监控系统的完整流程。首先对比了Sentry相较于Bugly的优势在于支持私有化部署和功能定制。系统要求包括Docker 19.03.6+、Compose 1.24.1+、4核CPU、8GB内存和20GB磁盘空间。安装过程涵盖Docker、Docker Compose的配置及国内镜像源设置，Sentry的安装部署方法，以及Android客户端的集成步骤。特别说明了混淆代码的mapping文件上传配置和Sen",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148817203",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 952,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148817203",
        "postTime": "2025-06-21 22:37:58",
        "diggCount": 23,
        "formatTime": "2025.06.21",
        "picList": [],
        "collectCount": 19,
        "tags": [
          "sentry",
          "android"
        ],
        "hasInsCode": false
      },
      {
        "articleId": 148817164,
        "title": "Android中测试驱动开发:使用Junit,Mockito,Robolectric进行单元测试=＞简介",
        "description": "再假如我们在登录的时候需要先验证密码强度，但是我们测试的时候不关心这个验证逻辑，希望不管传入的密码是啥，都可以通过验证。最近在看Androidx包下的测试框架，对于我们来讲，单元测试不是很多，测试代码跑在模拟器或者真机上带来的时间消耗还是可以接受的。这里说明一下，我们在写单元测试的时候，经常会需要初始化一些数据，但我们又不想在每个测试方法中都调用一遍初始化的方法，这里测试框架给出了四个注解。但是，假如我们的代码中不小心\"混入\"了一些调用Android包的功能，比如验证邮箱的有效性，代码可能是这样的。",
        "url": "https://blog.csdn.net/huangyuan_xuan/article/details/148817164",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 449,
        "commentCount": 0,
        "editUrl": "https://editor.csdn.net/md?articleId=148817164",
        "postTime": "2025-06-21 22:35:50",
        "diggCount": 7,
        "formatTime": "2025.06.21",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "android",
          "junit"
        ],
        "hasInsCode": false
      }
    ],
    "total": 330
  }
}